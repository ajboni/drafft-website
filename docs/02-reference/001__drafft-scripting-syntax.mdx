---
title: Drafft Scripting Syntax
description: Drafft's powerful script editor uses simple plain text to tell your game's characters exactly what to do and how to do it.
caption: Drafft Scripting Syntax
draft: true
---

# Scripting Syntax

The idea behind Drafft is that it should be engine- and language-agnostic. You are free to use whatever language you prefer for your game logic and runtime. However, certain features — such as dialogue flow, narration, and commands — require identifying the purpose of each line.

For this reason, the Drafft scripting syntax (UAF) exists.

UAF is intentionally minimal. It is designed to add **structure and meaning** to plain text without turning it into a full programming language. If you do not need these features, the syntax can be safely ignored.

---

## Scripting Rules

1. Scripts are read **top to bottom**, one line at a time.
2. Each line has a **single, clear purpose** (dialogue, comment, command, or control flow).
3. Control flow statements (`@if`, `@elseif`, `@else`, `@endif`) never produce output on their own.
4. Lines inside inactive control blocks are skipped entirely.
5. State changes persist forward for the remainder of the script.

---

## Evaluation Contexts

Drafft scripts can be interpreted in different contexts depending on how they are used.

The scripting syntax always describes **structure and intent**.  
Whether that intent is evaluated or executed depends on the context.

---

### Export Context

During export:

- No game state is assumed
- Control flow is preserved, not evaluated
- Conditions are not resolved
- Commands are emitted as descriptive instructions

This ensures scripts remain engine-agnostic, portable, and safe to transform.

---

### Simulation Context (Dialogue Simulator)

The Dialogue Simulator evaluates scripts using a temporary, simulated state.

In this context:

- Conditions are evaluated
- Control flow is executed
- Variable assignments affect simulated state
- Commands may be visualized or logged, but not executed

This allows authors to preview dialogue flow and branching logic without running the game.

---

### Runtime Context

At runtime:

- The game engine owns the state
- Conditions are evaluated using live game data
- Commands are executed according to engine logic

---

### Context Summary

| Context            | State Exists | Conditions Evaluated | Commands Executed |
| ------------------ | ------------ | -------------------- | ----------------- |
| Export             | No           | No                   | No                |
| Dialogue Simulator | Yes          | Yes                  | Simulated         |
| Game Runtime       | Yes          | Yes                  | Yes               |

---

:::tip
**Drafft defines structure and intent.  
Evaluation depends on context.**
:::

---

## Comments

```uaf
// Comment
```

Comments are lines that are commonly ignored in the target engine.
Drafft will include comments in the [screenplay](./screenplay_generation).

### Example

```uaf
// INT. SUBURBAN HOME - KITCHEN - NIGHT
// FILBERT (9), wiry, lost in his own imaginary world. Dressed as a Knight. A toy sword in his other hand.
```

---

## Actor Line (with Speech Tag)

```uaf
::Actor:: Actor Line [expression]
[#speechTag]::Actor:: Actor Line [expression]
```

Actor lines are the **core building block** of Drafft scripting.
They represent a line of dialogue spoken by an actor and carry semantic meaning beyond simple text.

An actor line is still valid, readable text on its own, but the syntax allows Drafft to identify _who_ is speaking, _what_ is being said, and _how_ that line should be interpreted or exported.

---

### Purpose

Actor lines serve multiple roles:

- Identify actors to build and maintain the **actor database**
- Identify spoken dialogue to **generate voice-over references**
- Include dialogue lines in the **generated screenplay**
- Attach **expressions or annotations** to dialogue without breaking readability
- Allow remapping to engine-specific formats during export

---

### Structure

#### Actor Identifier

```uaf
::Actor::
```

- `Actor` is treated as an identifier, not executable code
- The name is not validated or interpreted by the scripting system
- The same actor name can appear across multiple scripts

---

#### Dialogue Text

The dialogue text is the spoken content of the line and may include inline expressions.

```uaf
::Aries:: I have {{ gold }} coins.
```

---

### Speech Tags

Speech tags are optional identifiers used to uniquely reference a specific line of dialogue.

```uaf
[#speechTag]::Actor:: Actor Line
```

In most cases, **speech tags are automatically generated by Drafft** and do not need to be written manually.

---

#### Purpose of Speech Tags

Speech tags are primarily intended for:

- Voice-over pipelines
- Audio asset linking
- Localization workflows
- Stable references across exports and revisions

They allow dialogue lines to be tracked independently of their position in a script or their literal text.

---

#### Automatic Generation

When desired, Drafft automatically generates a speech tag for actor lines that do not already have one.

Generated tags are based on:

- The document alias
- A short, random identifier

This ensures:

- Tags are stable within a document
- Collisions are extremely unlikely
- Tags remain human-readable and diff-friendly

Example of an auto-generated tag:

```uaf
[#intro_a9F3]::Aries:: It's quieter than I expected.
```

---

#### Manual Tags (Optional)

While speech tags are usually auto-generated, they may also be written manually when explicit control is required.

```uaf
[#line001]::Travis:: You talkin' to me?
```

Manual tags must follow the same format and uniqueness rules as generated tags.

---

#### Format Rules

Speech tags must:

- Be wrapped in square brackets
- Start with `#`
- Contain only alphanumeric characters, underscores, or dots
- Have a minimum length of 6 characters (excluding `#`)

Valid examples:

```uaf
[#intro_4aZ9]
[#scene01.line02]
[#npcGreeting]
```

Invalid examples:

```uaf
[#hi]          // too short
[#hello-world] // invalid character
[# hello ]     // spaces not allowed
```

---

#### Execution Behavior

Speech tags:

- Do not affect control flow
- Do not affect execution
- Are ignored at runtime
- Are preserved during export

They exist purely as **metadata**.

---

#### Audio Tag Extraction

During export or processing, the speech tag identifier can be extracted without the surrounding brackets for use in audio or localization systems.

For example:

```uaf
[#library_8F2a]::Kenji:: Wow, it’s peaceful in here.
```

May produce:

```text
library_8F2a
```

as an audio or localization key.

---

#### Design Rationale

Speech tags are designed to be:

- Mostly invisible to writers
- Automatically managed by the tool
- Stable across script edits
- Friendly to external pipelines

This keeps scripts readable while still supporting production workflows.

---

### Expression Annotation

An (Optional) expression annotation can be added at the end of the line to provide contextual information, such as tone, emotion, or delivery.

```uaf
::Actor:: Actor Line [expression]
```

Expression annotations:

- Are treated as metadata
- Do not affect control flow or execution
- Are included in screenplay and export outputs

---

### Examples

```uaf
::Tyler:: The first rule of Fight Club is: You do not talk about Fight Club. [serious]
```

```uaf
[#line001]::Travis:: You talkin' to me?
```

```uaf
[#greeting_soft]::Aries:: It's nice to see you again. [warm]
```

---

### Export Behavior

Actor lines can be transformed during export to match the syntax or conventions of the target engine or pipeline.

For example:

- Renaming actors
- Converting speech tags to engine IDs
- Stripping or mapping expression annotations

See [Export Mappings](./exporting) for more details.

---

### Design Notes

Actor lines are intentionally:

- Human-readable
- Diff-friendly
- Independent of any specific engine or runtime

This allows Drafft scripts to function both as **working data** and as **long-term narrative documentation**.

---

## Commands

Commands represent **engine-defined actions** expressed declaratively inside a Drafft script.

Drafft **does not execute commands**.
Instead, commands are preserved, identified, and exported so they can be interpreted by the target game engine, runtime, or pipeline.

---

### Syntax

```uaf
<CommandName(arg1, arg2)>
```

- `CommandName` is an identifier
- Arguments are passed as plain values or expressions
- Drafft does not validate command names or arguments

---

### Examples

```uaf
<PlayBackgroundMusic("calm_library")>
<Pause(2)>
<ShowCharacter("Aries", "smiling")>
```

---

### Special Cases

Fade commands `<FadeOut(?params)>` and `<FadeIn(?params)>` also get some special treatment in the screenplay output.

---

### Execution Semantics

From Drafft’s perspective:

- Commands are **descriptive**, not executable
- They are emitted in order during export
- They are included only if their surrounding control flow is active
- Their meaning is defined entirely by the target engine or toolchain

Drafft treats commands as **structured intent**, not behavior.

---

### Control Flow Interaction

Commands respect control flow blocks:

```uaf
@if settings.musicEnabled
<PlayBackgroundMusic("calm_library")>
@endif
```

If the condition evaluates to false, the command line is skipped and will not appear in the exported output.

---

### Export Mappings

Commands may be transformed during export to match the conventions or APIs of the target engine.

For example:

- Renaming commands
- Rewriting arguments
- Converting commands into function calls, events, or data structures
- Removing unsupported commands

See [Export Mappings](./exporting) for details.

---

### Design Rationale

Commands are intentionally:

- Engine-agnostic
- Non-executable within Drafft
- Easy to identify and transform
- Safe to ignore if unsupported

This allows Drafft scripts to remain portable, readable, and adaptable across different engines and workflows without embedding engine logic into the scripting language itself.

---

## Control Flow Statements

Control flow statements define **conditional structure** inside a script.

They describe _intent and structure_, not execution.
Whether conditions are evaluated depends on the **evaluation context** (export, simulation, or runtime).

---

### Expressions and Resolution Model

All expressions reference values from the **evaluation context**.

Values are always accessed using the same structural pattern:

```
<collection>.<_sid>.<property>
```

The \_sid is a human-readable, author-defined identifier used exclusively for scripting and expression resolution.

```yaml
_sid: forestTrial
title: "The Forest Trial"
difficulty: Easy
```

#### Uniqueness and Validation

`\_sid` must be unique within its collection

- Conflicts are reported by Drafft during validation
- Scripts referencing ambiguous or missing `\_sid` values cannot be simulated or exported
- Drafft provides tooling assistance to help identify and resolve conflicts early.

Common roots include:

- `variables` (or `v`) — variables properties
- `quest` (or `q`) — quest properties and state
- `items` (or `i`) — item properties
- `actors` (or `a`) — actor properties
- `defaults` (or `d`) — authored default values

Examples:

```uaf
variables.player.courage
quest.forestTrial.courage
items.healthPotion.count
actors.Aries.mood
v.settings.speechVolume
i.sword.damage
a.Aries.mood
```

This consistency keeps scripts predictable, diff-friendly, and engine-agnostic.

---

### `@if`

```uaf
@if <expression>
```

Defines a conditional block.
The enclosed lines belong to the branch that should be taken **if the expression evaluates to true**.

Example:

```uaf
@if variables.player.courage > 5
::Aries:: You seem more confident.
@endif
```

#### Evaluation Context

- **Export context**
  The condition is preserved as-is. No evaluation occurs.
- **Simulation context**
  The expression is evaluated using simulated state to preview dialogue flow.
- **Runtime context**
  The expression is evaluated by the game engine using live game state.

---

### `@elseif`

```uaf
@elseif <expression>
```

Defines an additional conditional branch within the same `@if` block.

Rules:

- Evaluated only if all previous conditions in the block were false
- May appear multiple times
- Must appear before `@else`

Example:

```uaf
@if variables.player.courage > 7
::Aries:: You’re fearless now.
@elseif variables.player.courage > 3
::Aries:: You’re getting braver.
@else
::Aries:: You still seem unsure.
@endif
```

---

### `@else`

```uaf
@else
```

Defines a fallback branch that applies if no previous condition matched.

- Optional
- May appear only once per `@if` block

---

### `@endif`

```uaf
@endif
```

Ends a conditional block.

Every `@if` must have a matching `@endif`.

---

## State Assignment

### `@set`

```uaf
@set <target> = <expression>
```

Defines an assignment that may modify runtime state.

The assignment target **must** follow the standard resolution pattern:

```
<collection>.<_sid>.<property>
```

Example:

```uaf
@set variables.player.courage = variables.player.courage + 1
@set items.sword.condition = broken
@set defaults.quest.forestTrial.started = true
```

#### Evaluation Context

- **Export context**
  The assignment is preserved but not executed.
- **Simulation context**
  The assignment updates simulated state.
- **Runtime context**
  The assignment updates game state as defined by the engine.

#### Rules

- One assignment per line
- Left-hand side must be a writable reference
- Right-hand side must be a valid expression
- No side effects outside of the assignment itself

---

## Inline Interpolation (`${}`)

Inline interpolation allows you to **embed values from the evaluation context directly into text**.

It is commonly used inside actor lines, narration, and other plain-text content.

```uaf
${ expression }
```

Expressions inside `${}` follow the same resolution rules as control flow and assignments.

---

### Purpose

Inline interpolation is designed to:

- Insert dynamic values into dialogue and narration
- Reference variables and document properties
- Keep scripts readable and close to natural language

It does **not** execute logic and does **not** mutate state.

---

### Examples

```uaf
::Aries:: I feel like my courage is at ${variables.player.courage} today.
```

```uaf
::Narrator:: You have ${variables.player.gold} coins left.
```

```uaf
::Narrator:: Quest completed: ${quest.libraryVisit.title}
```

---

### Supported Expressions

Inline interpolation supports **simple, read-only expressions**:

- Property access

  ```uaf
  ${variables.player.courage}
  ```

  ```uaf
  ${quest.libraryVisit.courage}
  ```

The exact capabilities depend on the target engine or simulation environment.

---

### What `${}` Is Not

Inline interpolation is intentionally limited.

It does **not** support:

- Control flow (`if`, `else`, loops)
- Assignments or state mutation
- Function calls
- Access to engine APIs

All logic and decision-making must be expressed using `@` directives or handled by the target engine.

---

### Relationship to Control Flow

Inline interpolation does **not** affect whether a line is included or excluded.

Control flow is handled exclusively by `@if`, `@elseif`, `@else`, and `@endif`.

```uaf
@if quest.libraryVisit.courage > 2
  ::Aries:: I feel confident (${quest.libraryVisit.courage}).
@endif
```

In this example:

- `@if` determines whether the line exists
- `${}` only affects what is displayed

---

## Data Resolution: State vs Defaults

By design, **all property lookups resolve to runtime state by default**.

```uaf
${quest.forestTrial.courage}
```

To explicitly reference the authored default value, use the `defaults` root:

```uaf
${defaults.quest.forestTrial.courage}
```

### Resolution Summary

| Expression               | Resolves To               |
| ------------------------ | ------------------------- |
| `quest.x.y`              | Runtime quest state       |
| `variables.x.y`          | Runtime variable state    |
| `defaults.quest.x.y`     | Authored quest default    |
| `defaults.variables.x.y` | Authored variable default |

---

### Notes

- Whitespace inside `${}` is ignored
- Unresolved expressions may be:
  - left untouched
  - replaced with a fallback value
  - handled by the target engine
    _(implementation-specific)_

---

### Mental Model (recommended)

> **If it starts with `@`, it changes or decides something.
> If it’s inside `${}`, it only displays something.**

This separation is intentional and central to Drafft’s scripting philosophy.

---

## Inline JSON

Since v1.0.13 it is possible to inline standard JSON in both speech and commands lines. `%json` variable will contain parsed content.

Examples:

```uaf
::Reporter:: Now let's take a look at the weather for today.
<CutTo(Location1)> {"weather":"rainy"}
::FieldReporter:: Not looking very good here. {"props":["umbrella","raincoat", "microphone"]}
<CutTo(Studio)>
::Reporter:: What's the traffic on your side Mike?
<CutTo(Location2)> {"traffic": {"cars": "low", "trucks":"none"}}
::Mike:: Low traffic in this area.
```

JSON can be transformed at export time as well, see [Export Mappings](./exporting#inline-json)

---

## Common Misconceptions

A few clarifications that help avoid common sources of confusion:

- **“My `@if` didn’t run during export.”**
  This is expected. Control flow directives are **not evaluated during export**. They describe intent and are preserved for the target engine or simulation environment.
- **“Commands execute when the script is loaded.”**
  Drafft never executes commands. Commands are **descriptive markers** whose execution is entirely up to the game engine or tools consuming the exported data.
- **“The Dialogue Simulator defines how scripts behave in-game.”**
  The Dialogue Simulator is a **preview and debugging tool**. It evaluates scripts using its own evaluation context, but the game engine is always the final authority.
- **“Drafft replaces game logic.”**
  Drafft describes **narrative structure, flow, and intent**. Game logic, rules, and systems live in the engine.

---
